use crate::lexer::tokens::*;
use crate::lexer::LexicalError;
use crate::executor::ast::*;

grammar<'input>(input: &'input str);

pub SourceUnit:SourceUnit<'input> = {
    SourceUnitPart+ => SourceUnit(<>)
};

SourceUnitPart:SourceUnitPart<'input> = {
    Statement => SourceUnitPart::Statement(<>),
};

Statement:Statement<'input> = {
    Declaration <id:Expression> ";" => Statement::Declaration(id),
    <l:Expression> "=" <r:Expression> ";" => Statement::Assignment(l,r),
    Write <e:Expression> ";" => Statement::Write(e),
    If <condition:Conditional> "{" <s:SourceUnit> "}" => Statement::Conditional(condition,s,None),
    If <condition:Conditional> "{" <s:SourceUnit> "}" Else "{" <f:SourceUnit> "}" => Statement::Conditional(condition,s,Some(f)),
    Loop <condition:Conditional> "{" <s:SourceUnit> "}" => Statement::Loop(condition,s)
};

Expression:Expression<'input>= {
    ArithExpression
}

Conditional:Expression<'input> = {
    <l:Conditional>  <r:Conditional> "==" => Expression::Equals(Box::new(l),Box::new(r)),
    <l:Conditional>  <r:Conditional> "!=" => Expression::NotEquals(Box::new(l),Box::new(r)),
    <l:Conditional>  <r:Conditional> ">" => Expression::GreaterThan(Box::new(l),Box::new(r)),
    <l:Conditional>  <r:Conditional> "<" => Expression::LessThan(Box::new(l),Box::new(r)),
    Term,
};

ArithExpression: Expression<'input> = {
    <l:ArithExpression> "+" <r:Factor> => Expression::Add(Box::new(l),Box::new(r)),
    <l:ArithExpression> "-" <r:Factor> => Expression::Subtract(Box::new(l),Box::new(r)),
    Factor,
};

Factor: Expression<'input>= {
    <l:Factor> "*" <r:Unary> => Expression::Multiply(Box::new(l),Box::new(r)),
    <l:Factor> "/" <r:Unary> => Expression::Divide(Box::new(l),Box::new(r)),
    Unary,
};

Unary:Expression<'input> = {
    "-" <r:Unary> => Expression::UnaryMinus(Box::new(r)),
    Term
};

Term: Expression<'input>= {
    <v:Integer> => Expression::Integer(v),
    <id:Identifier> => Expression::Symbol(id),
    <string:StringLiteral> => Expression::StringLiteral(string),
    <InputNumber> => Expression::InputNumber,
    <InputString> => Expression::InputString,
    "(" <e:Expression> ")" => e
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum TokenType<'input> {
        Identifier => TokenType::Symbol(<&'input str>),
        ";" => TokenType::SemiColon,
        Declaration => TokenType::Declaration,
        "=" => TokenType::Assignment,
        Integer => TokenType::Number(i64),
        StringLiteral => TokenType::Literal(<&'input str>),
        "+" => TokenType::Plus,
        "-" => TokenType::Minus,
        "*" => TokenType::Product,
        "/" => TokenType::Divide,
        "(" => TokenType::OpenParantheses,
        ")" => TokenType::CloseParantheses,
        Write => TokenType::Write,
        If => TokenType::If,
        Else => TokenType::Else,
        ">" => TokenType::GreaterThan,
        "<" => TokenType::LessThan,
        "==" => TokenType::EqualTo,
        "!=" => TokenType::NotEqual,
        "{" => TokenType::LeftBrace,
        "}" => TokenType::RightBrace,
        Loop => TokenType::Loop,
        InputNumber => TokenType::InputNumber,
        InputString => TokenType::InputString,
        
    }
}